// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Email struct {
		Attachments func(childComplexity int) int
		Date        func(childComplexity int) int
		FromText    func(childComplexity int) int
		HTML        func(childComplexity int) int
		ID          func(childComplexity int) int
		MessageID   func(childComplexity int) int
		Subject     func(childComplexity int) int
		Text        func(childComplexity int) int
		TextAsHTML  func(childComplexity int) int
		ToText      func(childComplexity int) int
	}

	EmailAttachment struct {
		ContentDisposition func(childComplexity int) int
		ContentID          func(childComplexity int) int
		ContentType        func(childComplexity int) int
		Filename           func(childComplexity int) int
		GeneratedFileName  func(childComplexity int) int
		Size               func(childComplexity int) int
		TransferEncoding   func(childComplexity int) int
	}

	InvalidApiKeyError struct {
		Message func(childComplexity int) int
	}

	Mailbox struct {
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Username func(childComplexity int) int
	}

	Mutation struct {
		CreateMailbox func(childComplexity int, apiKey string) int
		Login         func(childComplexity int, username string, password string) int
		ReadMail      func(childComplexity int, mailID string) int
	}

	NewMailbox struct {
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Password func(childComplexity int) int
		Username func(childComplexity int) int
	}

	Query struct {
		Email   func(childComplexity int, id string) int
		Mailbox func(childComplexity int, name string) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Email.attachments":
		if e.complexity.Email.Attachments == nil {
			break
		}

		return e.complexity.Email.Attachments(childComplexity), true

	case "Email.date":
		if e.complexity.Email.Date == nil {
			break
		}

		return e.complexity.Email.Date(childComplexity), true

	case "Email.fromText":
		if e.complexity.Email.FromText == nil {
			break
		}

		return e.complexity.Email.FromText(childComplexity), true

	case "Email.html":
		if e.complexity.Email.HTML == nil {
			break
		}

		return e.complexity.Email.HTML(childComplexity), true

	case "Email._id":
		if e.complexity.Email.ID == nil {
			break
		}

		return e.complexity.Email.ID(childComplexity), true

	case "Email.messageId":
		if e.complexity.Email.MessageID == nil {
			break
		}

		return e.complexity.Email.MessageID(childComplexity), true

	case "Email.subject":
		if e.complexity.Email.Subject == nil {
			break
		}

		return e.complexity.Email.Subject(childComplexity), true

	case "Email.text":
		if e.complexity.Email.Text == nil {
			break
		}

		return e.complexity.Email.Text(childComplexity), true

	case "Email.textAsHtml":
		if e.complexity.Email.TextAsHTML == nil {
			break
		}

		return e.complexity.Email.TextAsHTML(childComplexity), true

	case "Email.toText":
		if e.complexity.Email.ToText == nil {
			break
		}

		return e.complexity.Email.ToText(childComplexity), true

	case "EmailAttachment.contentDisposition":
		if e.complexity.EmailAttachment.ContentDisposition == nil {
			break
		}

		return e.complexity.EmailAttachment.ContentDisposition(childComplexity), true

	case "EmailAttachment.contentId":
		if e.complexity.EmailAttachment.ContentID == nil {
			break
		}

		return e.complexity.EmailAttachment.ContentID(childComplexity), true

	case "EmailAttachment.contentType":
		if e.complexity.EmailAttachment.ContentType == nil {
			break
		}

		return e.complexity.EmailAttachment.ContentType(childComplexity), true

	case "EmailAttachment.filename":
		if e.complexity.EmailAttachment.Filename == nil {
			break
		}

		return e.complexity.EmailAttachment.Filename(childComplexity), true

	case "EmailAttachment.generatedFileName":
		if e.complexity.EmailAttachment.GeneratedFileName == nil {
			break
		}

		return e.complexity.EmailAttachment.GeneratedFileName(childComplexity), true

	case "EmailAttachment.size":
		if e.complexity.EmailAttachment.Size == nil {
			break
		}

		return e.complexity.EmailAttachment.Size(childComplexity), true

	case "EmailAttachment.transferEncoding":
		if e.complexity.EmailAttachment.TransferEncoding == nil {
			break
		}

		return e.complexity.EmailAttachment.TransferEncoding(childComplexity), true

	case "InvalidApiKeyError.message":
		if e.complexity.InvalidApiKeyError.Message == nil {
			break
		}

		return e.complexity.InvalidApiKeyError.Message(childComplexity), true

	case "Mailbox._id":
		if e.complexity.Mailbox.ID == nil {
			break
		}

		return e.complexity.Mailbox.ID(childComplexity), true

	case "Mailbox.name":
		if e.complexity.Mailbox.Name == nil {
			break
		}

		return e.complexity.Mailbox.Name(childComplexity), true

	case "Mailbox.username":
		if e.complexity.Mailbox.Username == nil {
			break
		}

		return e.complexity.Mailbox.Username(childComplexity), true

	case "Mutation.createMailbox":
		if e.complexity.Mutation.CreateMailbox == nil {
			break
		}

		args, err := ec.field_Mutation_createMailbox_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMailbox(childComplexity, args["apiKey"].(string)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["username"].(string), args["password"].(string)), true

	case "Mutation.readMail":
		if e.complexity.Mutation.ReadMail == nil {
			break
		}

		args, err := ec.field_Mutation_readMail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReadMail(childComplexity, args["mailId"].(string)), true

	case "NewMailbox._id":
		if e.complexity.NewMailbox.ID == nil {
			break
		}

		return e.complexity.NewMailbox.ID(childComplexity), true

	case "NewMailbox.name":
		if e.complexity.NewMailbox.Name == nil {
			break
		}

		return e.complexity.NewMailbox.Name(childComplexity), true

	case "NewMailbox.password":
		if e.complexity.NewMailbox.Password == nil {
			break
		}

		return e.complexity.NewMailbox.Password(childComplexity), true

	case "NewMailbox.username":
		if e.complexity.NewMailbox.Username == nil {
			break
		}

		return e.complexity.NewMailbox.Username(childComplexity), true

	case "Query.email":
		if e.complexity.Query.Email == nil {
			break
		}

		args, err := ec.field_Query_email_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Email(childComplexity, args["_id"].(string)), true

	case "Query.mailbox":
		if e.complexity.Query.Mailbox == nil {
			break
		}

		args, err := ec.field_Query_mailbox_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Mailbox(childComplexity, args["name"].(string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: sourceData("schema.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
